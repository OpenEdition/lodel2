#-*- coding: utf-8 -*-

## @package leapi.letype
# @brief Contains abstract class designed to be implemented by LeType
#
# @note LeObject will be generated by leapi.lefactory.LeFactory

import leapi
import EditorialModel.classtypes as lodel2const
from leapi.lecrud import _LeCrud, LeApiDataCheckError, LeApiQueryError
from leapi.leclass import _LeClass
from leapi.leobject import LeObjectError

## @brief Represent an EmType data instance
# @note Is not a derivated class of LeClass because the concrete class will be a derivated class from LeClass
class _LeType(_LeClass):
    
    ## @brief Stores selected fields with key = name
    _fields = list()
    ## @brief Allowed LeType superiors 
    _superiors = list()
    ## @brief Stores the class of LeClass
    _leclass = None
    ## @brief Stores the EM uid
    _type_id = None
    
    ## @brief Instanciate a new LeType
    # @param lodel_id : The lodel id
    # @param **kwargs : Datas used to populate a LeType
    def __init__(self, lodel_id, **kwargs):
        if self._leclass is None:
            raise NotImplementedError("Abstract class")

        if 'type_id' in kwargs:
            if self.__class__._type_id != int(kwargs['type_id']):
                raise RuntimeError("Trying to instanciate a %s with an type_id that is not correct"%self.__class__.__name__)
        if 'class_id' in kwargs:
            if self.__class__._class_id != int(kwargs['class_id']):
                raise RuntimeError("Trying to instanciate a %s with a clas_id that is not correct"%self.__class__.__name__)
        
        super().__init__(lodel_id, **kwargs)

    @classmethod
    def leo_class(cls):
        return cls._leclass

    @classmethod
    def fieldlist(cls):
        return cls._fields

    @classmethod
    def get(cls, query_filters, field_list = None, order = None, group = None, limit = None, offset = 0):
        query_filters.append(('type_id', '=', cls._type_id))
        return super().get(query_filters, field_list, order, group, limit, offset)

    @classmethod
    def fieldtypes(cls):
        super_fieldtypes = super().fieldtypes()
        return { fname: super_fieldtypes[fname] for fname in super_fieldtypes if fname in cls._fields }

    ## @brief Get all the datas for this LeType
    # @return a dict with fieldname as key and field value as value
    # @warning Can represent a performance issue
    def all_datas(self):
        self.populate()
        return self.datas()
    
    ## @brief Delete current instance from DB
    def delete(self):
        _LeCrud._delete(self)
    
    ## @brief Add a superior
    # @param lesup LeObject : LeObject child class instance
    # @param nature str : Relation nature
    # @param del_if_exists bool : If true delete the superior if any before setting the new one
    # @return relation id if successfully created else returns false
    def add_superior(self, superior, nature, del_if_exists = False):
        lehierarch = self.name2class('LeHierarch')
        if del_if_exists: #Duplicated test with lehierarch.insert
            prev_sup = lehierarch.get(
                [(lehierarch._subordinate_field_name, '=', self), ('nature', '=', nature)],
                [ lehierarch.uidname() ]
            )
            if len(prev_sup) > 0:
                for todel_sup in prev_sup: #This loop shoud be useless...but we never know
                    todel_sup.delete()

        return lehierarch.insert({'superior':superior, 'subordinate':self, 'nature':nature})

    ## @brief Link the LeObject with another one (rel2type relations)
    #
    # @note This methods asser that self is the superior and leo_tolink the subordinate
    #
    # @param leo_tolink LeObject : LeObject child instance to link with
    # @param relation_name str : Name of the relation (the fieldname of the rel2type in the EmClass)
    # @param datas dict : Relation attributes (if any)
    # @return a relation id if success
    def link_with(self, leo_tolink, relation_name, datas):
        # Fetch rel2type leapi class
        r2t = self.name2class('LeRel2Type')
        class_name = r2t.relname(self, leo_tolink.__class__, relation_name)
        r2tcls = self.name2class(class_name)
        if not r2tcls:
            raise ValueError("No rel2type possible between a '%s' as superior and a '%s' as subordinate" % (self._leclass.__name__, leo_tolink.__class__.__name__))
        datas['superior'] = self
        datas['subordinate'] = leo_tolink
        datas[lodel2const.relation_name] = relation_name
        return r2tcls.insert(datas, class_name)
