##@defgroup lodel2_leapi LeAPI
#@brief Lodel2 Editorial API
#
#Provide access to datas via objects as defined in the Editorial Model

##@package lodel.leapi
#@brief Lodel2 Editorial API
#
# Defines an API to access to objects as described by 
#@ref lodel.editorial_model "Editorial Model"

##@page lodel2_leapi_page LeAPI
#@ingroup lodel2_leapi
#
# @section lodel2_leapi_base LeAPI (Lodel Editorial API)
#
# LeAPI is an API that provide access to datas as defined in an 
#@ref lodel2_em "Editorial Model".
#
#@subsection lodel2_leapi_gen LeAPI dynamic code & LeFactory
#
#LeAPI python code is programmaticaly generated by 
#@ref lodel.leapi.lefactory "LeFactory". LeFactory generates 
#@ref lodel.leapi.leobject.LeObject "LeObject" child classes.
#
#@par Example
#<pre>
#
#    from lodel.leapi.leobject import LeObject
#    from lodel.leapi.datahandlers.base_classes import DataField
#    from lodel.plugin.hooks import LodelHook
#
#    class Abstract_Object(LeObject):
#        _abstract = True
#        _fields = None
#        _uid = []
#        _ro_datasource = None
#        _rw_datasource = None
#        _datasource_name = 'default'
#        _child_classes = None
#
#
#    class User(LeObject):
#        _abstract = False
#        _fields = None
#        _uid = ['id']
#        _ro_datasource = None
#        _rw_datasource = None
#        _datasource_name = 'default'
#        _child_classes = None
#
#
#    class Object(Abstract_Object):
#        _abstract = True
#        _fields = None
#        _uid = ['lodel_id']
#        _ro_datasource = None
#        _rw_datasource = None
#        _datasource_name = 'default'
#        _child_classes = None
#
#
#    class Entry(Object):
#        _abstract = True
#        _fields = None
#        _uid = ['lodel_id']
#        _ro_datasource = None
#        _rw_datasource = None
#        _datasource_name = 'default'
#        _child_classes = None
#
#
#    class Entitie(Object):
#        _abstract = True
#        _fields = None
#        _uid = ['lodel_id']
#        _ro_datasource = None
#        _rw_datasource = None
#        _datasource_name = 'default'
#        _child_classes = None
#
#
#    class Person(Object):
#        _abstract = False
#        _fields = None
#        _uid = ['lodel_id']
#        _ro_datasource = None
#        _rw_datasource = None
#        _datasource_name = 'default'
#        _child_classes = None
#
#    class Text(Entitie):
#        _abstract = True
#        _fields = None
#        _uid = ['lodel_id']
#        _ro_datasource = None
#        _rw_datasource = None
#        _datasource_name = 'default'
#        _child_classes = None
#
#
#    class Publication(Entitie):
#        _abstract = False
#        _fields = None
#        _uid = ['lodel_id']
#        _ro_datasource = None
#        _rw_datasource = None
#        _datasource_name = 'default'
#        _child_classes = None
#
#    Abstract_Object._set__fields({})
#    Abstract_Object._child_classes = (Section, Text, Object, Entry, Collection, Text_Person, Entitie, Indextheme, Person, Indexabs, Publication, Subsection,)
#    User._set__fields({
#            'firstname': DataField.from_name('varchar')(**{ 'internal': False }), 
#            'lastname': DataField.from_name('varchar')(**{ 'internal': False }), 
#            'classname': DataField.from_name('LeobjectSubclassIdentifier')(**{ 'internal': True }), 
#            'login': DataField.from_name('varchar')(**{ 'internal': True, 'uniq': True }), 
#            'id': DataField.from_name('uniqid')(**{ 'internal': True }), 
#            'password': DataField.from_name('password')(**{ 'internal': False })})
#    User._child_classes = tuple()
#    Object._set__fields({
#            'date_update': DataField.from_name('datetime')(**{ 'now_on_update': True, 'internal': True }), 
#            'lodel_id': DataField.from_name('uniqid')(**{ 'internal': True }), 
#            'help_text': DataField.from_name('text')(**{ 'internal': True }), 
#            'date_create': DataField.from_name('datetime')(**{ 'internal': True, 'now_on_create': True })})
#    Object._child_classes = (Section, Text, Entry, Collection, Text_Person, Entitie, Indextheme, Person, Indexabs, Publication, Subsection,)
#    Entry._set__fields({
#            'date_update': DataField.from_name('datetime')(**{ 'now_on_update': True, 'internal': True }), 
#            'lodel_id': DataField.from_name('uniqid')(**{ 'internal': True }), 
#            'help_text': DataField.from_name('text')(**{ 'internal': True }), 
#            'date_create': DataField.from_name('datetime')(**{ 'internal': True, 'now_on_create': True })})
#    Entry._child_classes = tuple()
#    Entitie._set__fields({
#            'date_update': DataField.from_name('datetime')(**{ 'now_on_update': True, 'internal': True }), 
#            'lodel_id': DataField.from_name('uniqid')(**{ 'internal': True }), 
#            'help_text': DataField.from_name('text')(**{ 'internal': True }), 
#            'date_create': DataField.from_name('datetime')(**{ 'internal': True, 'now_on_create': True })})
#    Entitie._child_classes = (Section, Text, Text_Person, Collection, Publication, Subsection,)
#    Person._set__fields({
#            'date_update': DataField.from_name('datetime')(**{ 'now_on_update': True, 'internal': True }), 
#            'firstname': DataField.from_name('varchar')(**{  }), 
#            'lodel_id': DataField.from_name('uniqid')(**{ 'internal': True }), 
#            'linked_texts': DataField.from_name('list')(**{ 'nullable': True, 'default': None, 'allowed_classes': [Text], 'back_reference': (Text, 'linked_persons') }), 
#            'help_text': DataField.from_name('text')(**{ 'internal': True }), 
#            'lastname': DataField.from_name('varchar')(**{  }), 
#            'fullname': DataField.from_name('Concat')(**{ 'field_list': ['firstname', 'lastname'], 'immutable': True }), 
#            'classname': DataField.from_name('LeobjectSubclassIdentifier')(**{ 'internal': True }), 
#            'alias': DataField.from_name('set')(**{ 'nullable': True, 'default': None, 'allowed_classes': [Person] }), 
#            'date_create': DataField.from_name('datetime')(**{ 'internal': True, 'now_on_create': True })})
#    Person._child_classes = tuple()
#    Text._set__fields({
#            'date_update': DataField.from_name('datetime')(**{ 'now_on_update': True, 'internal': True }), 
#            'subtitle': DataField.from_name('varchar')(**{ 'nullable': True, 'default': None }), 
#            'lodel_id': DataField.from_name('uniqid')(**{ 'internal': True }), 
#            'help_text': DataField.from_name('text')(**{ 'internal': True }), 
#            'linked_persons': DataField.from_name('list')(**{ 'nullable': True, 'default': None, 'allowed_classes': [Person], 'back_reference': (Person, 'linked_texts') }), 
#            'indexes': DataField.from_name('list')(**{ 'nullable': True, 'default': None, 'allowed_classes': [Indexabs], 'back_reference': (Indexabs, 'texts') }), 
#            'title': DataField.from_name('varchar')(**{ 'nullable': True }), 
#            'date_create': DataField.from_name('datetime')(**{ 'internal': True, 'now_on_create': True })})
#    Text._child_classes = (Section, Subsection,)
#    Publication._set__fields({
#            'date_update': DataField.from_name('datetime')(**{ 'now_on_update': True, 'internal': True }), 
#            'classname': DataField.from_name('LeobjectSubclassIdentifier')(**{ 'internal': True }), 
#            'lodel_id': DataField.from_name('uniqid')(**{ 'internal': True }), 
#            'collection': DataField.from_name('link')(**{ 'back_reference': (Collection, 'publications') }), 
#            'help_text': DataField.from_name('text')(**{ 'internal': True }), 
#            'date_create': DataField.from_name('datetime')(**{ 'internal': True, 'now_on_create': True })})
#    Publication._child_classes = tuple()
#
#    #List of dynamically generated classes
#    dynclasses = [Abstract_Object, User, Object, Entry, Entitie, Person, Indexabs, Text, Publication, Collection, Indextheme, Text_Person, Section, Subsection]
#    #Dict of dynamically generated classes indexed by name
#    dynclasses_dict = {'Abstract_Object': Abstract_Object, 'User': User, 'Object': Object, 'Entry': Entry, 'Entitie': Entitie, 'Person': Person, 'Indexabs': Indexabs, 'Text': Text, 'Publication': Publication, 'Collection': Collection, 'Indextheme': Indextheme, 'Text_Person': Text_Person, 'Section': Section, 'Subsection': Subsection}
#
#
#    ##@brief Return a dynamically generated class given it's name
#    #@param name str : The dynamic class name
#    #@return False or a child class of LeObject
#    def name2class(name):
#        if name not in dynclasses_dict:
#            return False
#        return dynclasses_dict[name]
#
#
#    ##@brief Return a dynamically generated class given it's name
#    #@note Case insensitive version of name2class
#    #@param name str
#    #@retrun False or a child class of LeObject
#    def lowername2class(name):
#        name = name.lower()
#        new_dict = {k.lower():v for k,v in dynclasses_dict.items()}
#        if name not in new_dict:
#            return False
#        return new_dict[name]
#
#
#    ##@brief Trigger dynclasses datasources initialisation
#    @LodelHook("lodel2_plugins_loaded")
#    def lodel2_dyncode_datasources_init(self, caller, payload):
#        for cls in dynclasses:
#            cls._init_datasources()
#        from lodel.plugin.hooks import LodelHook
#        LodelHook.call_hook("lodel2_dyncode_loaded", __name__, dynclasses)
#
#
#
#</pre>
#
