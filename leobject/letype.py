#-*- coding: utf-8 -*-

## @package leobject API to access lodel datas
#
# This package contains abstract classes leobject.leclass.LeClass , leobject.letype.LeType, leobject.leobject._LeObject.
# Those abstract classes are designed to be mother classes of dynamically generated classes ( see leobject.lefactory.LeFactory )

## @package leobject.leobject
# @brief Abstract class designed to be implemented by LeObject
#
# @note LeObject will be generated by leobject.lefactory.LeFactory

import leobject
from leobject.leclass import LeClass
from leobject.leobject import LeObjectError

## @brief Represent an EmType data instance
# @note Is not a derivated class of LeClass because the concrete class will be a derivated class from LeClass
class LeType(object):
    
    ## @brief Stores selected fields with key = name
    _fields = list()
    ## @brief Allowed LeType superiors 
    _superiors = list()
    ## @brief Stores the class of LeClass
    _leclass = None
    ## @brief Stores the EM uid
    _type_id = None
    
    ## @brief Instanciate a new LeType
    # @param lodel_id : The lodel id
    # @param **kwargs : Datas used to populate a LeType
    def __init__(self, lodel_id, **kwargs):
        if self._leclass is None:
            raise NotImplementedError("Abstract class")

        self.lodel_id = lodel_id

        if 'type_id' in kwargs:
            if self.__class__._type_id != int(kwargs['type_id']):
                raise RuntimeError("Trying to instanciate a %s with an type_id that is not correct"%self.__class__.__name__)
        if 'class_id' in kwargs:
            if self.__class__._class_id != int(kwargs['class_id']):
                raise RuntimeError("Trying to instanciate a %s with a clas_id that is not correct"%self.__class__.__name__)

        ## Populate the object from the datas received in kwargs
        for name, value in kwargs.items():
            if name not in self._fields:
                raise AttributeError("No such field '%s' for %s"%(name, self.__class__.__name__))
            setattr(self, name, value)
    
    ## @brief Populate the LeType wih datas from DB
    # @param field_list None|list : List of fieldname to fetch. If None fetch all the missing datas
    def populate(self, field_list=None):
        if field_list == None:
            field_list = [ fname for fname in self._fields if not hasattr(self, fname) ]
        filters, rel_filters = self._prepare_filters(['lodel_id = %d'%(self.lodel_id)], self.__class__, self._leclass)

        fdatas = self._datasource.get(self._leclass, self.__class__, field_list, filters, rel_filters)
        for fname, fdats in fdatas[0].items():
            setattr(self, name, value)

    ## @brief Get a fieldname:value dict
    # @return A dict with field name as key and the field value as value
    @property
    def datas(self):
        return { fname: getattr(self, fname) for fname in self._fields if hasattr(self,fname) }
    
    ## @brief Get all the datas for this LeType
    # @return a dict with fieldname as key and field value as value
    # @warning Can represent a performance issue
    def all_datas(self):
        self.populate()
        return self.datas
    
    ## @brief Delete the LeType from Db
    # @note equivalent to LeType::delete(filters=['lodel_id = %s'%self.lodel_id)
    def db_delete(self):
        return self.delete([('lodel_id','=',repr(self.lodel_id))])
    
    ## @brief Add a superior given a nature
    # @param leo LeObject : A LeObject instance that will be the superior
    # @param nature str : the relation nature
    # @throw leobject.leobject.LeObjectError if this
    # @todo find what value depth and rank should have....
    # @todo Unit tests
    def add_superior(self, leo, nature):
        if nature not in self._superiors.keys():
            raise LeObjectError("%s cannot have a superior with %s as relation nature"%(self.__class__.__name__, nature))
        if leo.__class__ not in self._superiors[nature]:
            raise LeObjectError("%s cannot have a %s superior in a %s relation"%(self.__class__.__name__, leo.__class__.__name__, nature))

        return self._datasource.add_relation(leo.lodel_id, self.lodel_id, nature = nature, depth=None, rank = None)
    
    ## @brief Delete a superior given a nature
    # @param leo LeObject : A LeObject instance
    # @param nature str : The relation nature
    # @todo Unit tests
    def del_superior(self, leo, nature):
        if nature is None:
            raise ValueError('The argument nature cannot be None')
        return self._datasource(leo, self, nature)

    ## @brief Get the linked objects lodel_id
    # @return an array of lodel_id linked with this object
    # @todo unit tests
    def linked(self):
        return [ rel['id_sub'] for rel in self._datasource.get_relations(self.lodel_id) ]

    ## @brief Link this object with a LeObject
    # @note rel2type
    # @param leo LeObject : The object to be linked with
    # @param **rel_attr : keywords arguments for relations attributes
    # @return True if success False allready done
    # @throw A Leo exception if the link is not allowed
    # @todo unit tests
    # @todo find a value for depth and rank....
    def link_to(self, leo, **rel_attr):
        if leo.__class__ not in self._linked_types.keys():
            raise leobject.leobject.LeObjectError("Constraint error : %s cannot be linked with %s"%(self.__class__.__name__, leo.__class__.__name__))

        for attr_name in rel_attr.keys():
            if attr_name not in [ f for f,g in self._linked_types[leo.__class__] ]:
                raise AttributeError("A rel2type between a %s and a %s doesn't have an attribute %s"%(self.__class__.__name__, leo.__class__.__name__, attr_name))
            if not self._linked_types[leo.__class__][1].check(rel_attr[attr_name]):
                raise ValueError("Wrong value '%s' for attribute %s"%(rel_attr[attr_name], attr_name))

        return self._datasource.add_relation(self, leo, nature=None, depth=None, rank=None, **rel_attr)

    ## @brief Remove a link bewteen this object and another
    # @param leo LeObject : A LeObject instance linked with self
    # @todo unit tests
    def unlink(self, leo):
        return self._datasource.del_relation(self, leo)
        
    ## @brief Delete a LeType from the datasource
    # @param filters list : list of filters (see @ref leobject_filters)
    # @param cls
    # @return True if deleted False if not existing
    # @throw InvalidArgumentError if invalid parameters
    # @throw Leo exception if the lodel_id identify an object from another type
    @classmethod
    def delete(cls, filters):
        return leobject.lefactory.LeFactory.leobject().delete(cls, filters)
        
    ## @brief Update a LeType in db
    def db_update(self):
        return self.update(filters=[('lodel_id', '=', repr(self.lodel_id))], datas = self.datas)
        
    @classmethod
    ## @brief Update some LeType in db
    # @param datas : keys are lodel_id and value are dict of fieldname => value
    # @param filters list : list of filters (see @ref leobject_filters)
    # @param cls
    # return bool
    def update(cls, filters, datas):
        return leobject.lefactory.LeFactory.leobject().update(letype = cls, filters = filters, datas = datas)
        
    ## @brief Insert a new LeType in the datasource
    # @param **datas list : A list of dict containing the datas
    # @return The lodel id of the new LeType or False
    # @thorw A leo exception if invalid stuff
    # @throw InvalidArgumentError if invalid argument
    @classmethod
    def insert(cls, datas):
        return super(LeType, cls).insert(letype=cls, datas=datas)
    
    ## @brief Check that datas are valid for this type
    # @param datas dict : key == field name value are field values
    # @param complete bool : if True expect that datas provide values for all non internal fields
    # @param allow_internal bool : if True don't raise an error if a field is internal
    # @throw TypeError If the datas are not valids
    # @throw AttributeError if datas provides values for automatic fields
    # @throw AttributeError if datas provides values for fields that doesn't exists
    @classmethod
    def check_datas_or_raise(cls, datas, complete = False, allow_internal = True):
        autom_fields = [f for f, ft in cls._fieldtypes.items() if hasattr(ft,'internal') and ft.internal]
        for dname, dval in datas.items():
            if not allow_internal and dname in autom_fields:
                raise AttributeError("The field '%s' is internal"%(dname))
            if dname not in cls._fields:
                raise AttributeError("No such field '%s' for %s"%(dname, cls.__name__))
            cls._fieldtypes[dname].check_or_raise(dval)
        
        fields = [f for f, ft in cls._fieldtypes.items() if not hasattr(ft,'internal') or not ft.internal and f in cls._fields]
        if complete and len(datas) < len(fields):
            raise LeObjectError("The argument complete was True but some fields are missing : %s"%(set(fields) - set(datas.keys())))
        
    
    ## @brief Check that datas are valid for this type
    # @param datas dict : key == field name value are field values
    # @param complete bool : if True expect that datas provide values for all non internal fields
    # @param cls
    # @return True if check pass else False
    def check_datas(cls, datas, complete = False):
        try:
            cls.check_datas_or_raise(datas, complete)
        except (TypeError, AttributeError, LeObjectError):
            return False
        return True

    ## @brief Implements the automatic checks of attributes
    # @note Run data check from fieldtypes if we try to modify an field attribute of the LeType
    # @param name str : The attribute name
    # @param value * : The value
    def __setattr__(self, name, value):
        if name in self._fields:
            self._fieldtypes[name].check_or_raise(value)
        return super(LeType, self).__setattr__(name, value)
    
